package com.pretzel

import java.io.File
import java.util.Stack

class Lexer(_source: String, mode: SourceMode) {
    enum class SourceMode {
        FILE,
        DIRECT,
    }

    enum class TokenType {
        ASSIGN,
        AT,
        BOOL,
        BREAK,
        BYTE_LITERAL,
        CLASS,
        COLON,
        COMMA,
        CONCAT_COMMA,
        CONCAT_SPACE,
        DIV,
        DOT,
        ELIF,
        ELSE,
        EQ,
        ERROR,
        FLOAT_LITERAL,
        FUNC,
        GT,
        GTEQ,
        HASHTAG,
        IDENTIFIER,
        IF,
        IN,
        INTEGER_LITERAL,
        IS,
        LBRACE,
        LONG_LITERAL,
        LPAREN,
        LT,
        LTEQ,
        MINUS,
        MOD,
        MUL,
        NO,
        NOT,
        SEMI,
        NOTEQ,
        NOTHING,
        PLUS,
        POW,
        RBRACE,
        RPAREN,
        SHORT_LITERAL,
        LSQB,
        RSQB,
        STRING_LITERAL,
        CHARACTER_LITERAL,
        TEMPLATE_STRING,
        USE,
        VAR,
        WHEN,
        YES,
        XOR,
        // no token
        INVALID,
    }

    data class Token(
        val lexeme: String?, val type: TokenType,
        val line: Int, val column: Int, val file: String) {
        companion object {
            val NULL_TOKEN: Token = Token("", TokenType.INVALID, -1, -1, "")
        }

        override operator fun equals(other: Any?): Boolean {
            if (other == null || other !is Token)
                return false

            if (other.hashCode() == hashCode())
                return true

            return line == other.line && column == other.column && file == other.file && type == other.type
        }

        override fun toString(): String {
            return "${type}('${lexeme}' ${line}:${column})@${file}"
        }

        // autogenerated
        override fun hashCode(): Int {
            var result = lexeme.hashCode()
            result = 31 * result + type.hashCode()
            result = 31 * result + line.hashCode()
            result = 31 * result + column
            result = 31 * result + file.hashCode()
            return result
        }
    }

    private val kwds: Map<String, TokenType> = mapOf(
        "bool" to TokenType.BOOL,
        "break" to TokenType.BREAK,
        "elif" to TokenType.ELIF,
        "else" to TokenType.ELSE,
        "error" to TokenType.ERROR,
        "func" to TokenType.FUNC,
        "if" to TokenType.IF,
        "in" to TokenType.IN,
        "is" to TokenType.IS,
        "no" to TokenType.NO,
        "nothing" to TokenType.NOTHING,
        "use" to TokenType.USE,
        "when" to TokenType.WHEN,
        "yes" to TokenType.YES,
        "class" to TokenType.CLASS,
        "mod" to TokenType.MOD,
    )


    private var line: Int = 1
    private var column: Int = 1
    private var pos: Int = 0
    private var source: String
    private val mode: SourceMode
    private var done: Boolean = false
    private val sourceLength: Int
        get() = source.length

    val file: File?
        get() {
            return when (mode) {
                SourceMode.FILE -> File(source)
                SourceMode.DIRECT -> null
            }
        }

    val tokens: Stack<Token> = Stack()

    init {
        source = when (mode) {
            SourceMode.FILE -> File(_source).readText()
            SourceMode.DIRECT -> _source
        }

        this.mode = mode
    }

    private fun shiftInLine() {
        pos++
        column++
    }

    private fun isAtEnd(n: Int = 0): Boolean {
        return pos + n >= sourceLength
    }

    private fun peek(n: Int = 0): Char {
        if (isAtEnd(n)) return '\u0000'
        return source[pos + n]
    }

    private fun next(): Char {
        val c = peek()
        if (c == '\n') {
            line++
            column = 1
        } else column++

        pos++
        return c
    }

    private fun isDigit(c: Char) = c in '0'..'9'

    private fun isAlpha(c: Char) = c in 'a'..'z' || c in 'A'..'Z' || c == '_'

    private fun isAlphaNumeric(c: Char) = isAlpha(c) || isDigit(c)

    private fun match(expected: Char): Boolean {
        if (isAtEnd()) return false
        if (source[pos] != expected) return false
        pos++
        column++
        return true
    }

    private fun divOrComment() {
        if (match('/'))
            while (peek() != '\n' && !isAtEnd()) next()
        else if (match('*')) {
            while (peek() != '*') {
                next()
                if (isAtEnd()) throw RuntimeException("unterminated block comment")
            }

            next()
            if (peek() != '/')
                throw RuntimeException("unterminated block comment")

            next(); next() // remaining * and /
        } else pushToken(TokenType.DIV)
    }

    private fun string(char: Boolean) {
        val result = StringBuilder()
        if (char) {
            
        } else while (peek() != '"' && !isAtEnd()) result.append(next())

        if (isAtEnd()) throw RuntimeException("Unterminated string.")
        next()

        pushToken(TokenType.STRING_LITERAL, result.toString())
    }

    private fun number(startDigit: Char, possibleByte: Boolean) {
        val result = StringBuilder()
        val isbyte = possibleByte && peek().toLowerCase() == 'x'
        if (isbyte) {
            result.append("x")
            next()
            while (peek().isDigit() || peek() in "abcdef") result.append(next())
            pushToken(TokenType.BYTE_LITERAL, "0$result")
            return
        }

        while (peek().isDigit()) result.append(next())
        var frac = false
        var long = false
        var short = false

        if (peek() == '.' && peek(1).isDigit() && !isbyte) {
            frac = true
            result.append(next())
            while (peek().isDigit()) result.append(next())
        } else if (peek().toLowerCase() == 'l') {
            long = true
            next()
        } else if (peek().toLowerCase() == 's') {
            short = true
            next()
        }


        pushToken(
                if (frac)
                    TokenType.FLOAT_LITERAL
                else if (long)
                    TokenType.LONG_LITERAL
                else if (short)
                    TokenType.SHORT_LITERAL
                else
                    TokenType.INTEGER_LITERAL,
            startDigit + result.toString())
    }

    private fun identifier(startDigit: Char) {
        val result = StringBuilder(startDigit.toString())
        while (isAlphaNumeric(peek())) result.append(next())
        // See if the identifier is a reserved word.
        val text = result.toString()

        val type: TokenType?
        type = if (text !in kwds.keys) TokenType.IDENTIFIER
        else kwds[text]
        pushToken(type!!, result.toString())
    }

    private fun pushToken(type: TokenType, literal: String? = null) =
                    tokens.push(Token(literal, type, line, column, if (file == null) "<input>" else file!!.name))

    private fun getNextToken() {
        when (val c = next()) {
            '\u0000' -> done = true
            '(' -> pushToken(TokenType.LPAREN)
            ')' -> pushToken(TokenType.RPAREN)
            '{' -> pushToken(TokenType.LBRACE)
            '}' -> pushToken(TokenType.RBRACE)
            '[' -> pushToken(TokenType.LSQB)
            ']' -> pushToken(TokenType.RSQB)
            ',' -> pushToken(TokenType.COMMA)
            '-' -> pushToken(TokenType.MINUS)
            '+' -> pushToken(TokenType.PLUS)
            ';' -> pushToken(TokenType.SEMI)
            '*' -> pushToken(TokenType.MUL)
            ':' -> pushToken(TokenType.COLON)
            '@' -> pushToken(TokenType.AT)
            '#' -> pushToken(TokenType.HASHTAG)
            '$' -> pushToken(TokenType.VAR)
            '^' -> {
                if (match('^')) pushToken(TokenType.POW)
                else pushToken(TokenType.XOR)
            }
            '.' -> {
                if (match('.')) {
                    if (match('.')) {
                        pushToken(TokenType.CONCAT_COMMA)
                    } else pushToken(TokenType.CONCAT_SPACE)
                } else pushToken(TokenType.DOT)
            }
            '!' -> pushToken(if (match('=')) TokenType.NOT else TokenType.NOTEQ)
            '=' -> pushToken(if (match('=')) TokenType.ASSIGN else TokenType.EQ)
            '<' -> pushToken(if (match('=')) TokenType.LTEQ else TokenType.LT)
            '>' -> pushToken(if (match('=')) TokenType.GTEQ else TokenType.GT)
            '/' -> divOrComment()
            ' ', '\r' -> { /* ignore */ }
            '\t' -> { shiftInLine() }
            '\n' -> line++
            '"' -> string()
            in '0'..'9' -> number(c, c == '0')
            else -> {
                if (isAlpha(c)) identifier(c)
                else throw RuntimeException("Unexpected character '$c'.")
            }
        }
    }

    fun getAllTokens() {
        while (!isAtEnd()) getNextToken()
    }
}